## 해당 README.md는 Brute force에 대한 README입니다.
---
## Brute force 알고리즘
가능한 모든 경우의 수를 탐색하면서 요구조건에 충족되는 결과를 가져온다. 
즉, 해가 존재할 것으로 예상되는 모든 영역을 전체적으로 탐색하는 방법이다.
예외없이 100%의 확률로 정답을 출력한다.

예시로는 순차탐색, DFS, BFS가 있다.

<br>
## 분해값
해당 알고리즘은 1,000,000번의 연산을 필요하므로, 주어진 시간으로 볼 때 브루트 포스 알고리즘으로 풀 수 있다.

## 풀었던 방식
N의 최대의 범위가 1,000,000이고, 생성자는 N보다는 필수적으로 작다. 그러므로 생성자는 6자리의 숫자일 것이고, 생성자의 자릿수의 최댓값은 54(999,999일 경우)이다.
N = 생성자 + 생성자의 자릿수이므로, 결국 생성자가 있을 수 있는 범위의 값은 N-54일 것으로 생각하고 반복문을 통해 찾아냈다.
<br>

## 부족했던 점
일단 Brute force적으로 접근하지 못했다! 사실 Brute force라는 개념을 언제 대입을 하는 것인지를 알려고 문제를 푸는데, 결과적으로는 실패였다.
하지만 개인적으로 54회만의 반복으로 값을 찾을 수 있다는 점에서 효율적인 방법을 찾은 것 같아 만족했다.

## 부족했던 점을 바탕으로 짠 코드
```
#include <iostream>
#include <algorithm>

int sum;
int a[1000000] = { 0, };

int calc_digits_sum(int M) {

	sum = 0;
	while (M > 0) {
		sum += M % 10;
		M = M / 10;
	};

	return sum;
}

int main() {

	int N, digit_sum = 0, decomposition=0;

	std::cin >> N;
	for (int i = 0; i < N; i++) {
		digit_sum = calc_digits_sum(i);

		if (N - digit_sum == i) {
			decomposition = i;
			break;
		}
	}
	std::cout << decomposition << '\n';

}
```
<br>
## Double

## 풀었던 방식
반복문을 이용해 index의 값을 올리면서 배열에 입력받은 값을 대입하고, 만일 n = 0인 경우에 반복문을 index 값까지 돌려서, element마다 2를 곱하여 stl find 함수를 통해 배열 내부에 2배의 숫자가 있는 지를 점검하였다. 

## 부족한 점
stl sort함수를 이용하여 오름차순을 했는데 현재 코드를 보면 없어도 되는 것 같다. 오름차순을 이용하여 더 효율적으로 코드를 운용하겠다는 계획이었는데 결국 find로 처음부터 찾는 셈이 되었기 때문이다. 코드를 짤 때에는 왜 이러한 함수를 쓰는 지 한 번 더 생각을 하자.

<br>

## 덩치

<br>
## 풀었던 방식
사용자의 덩치를 입력받는 배열 build_info와 랭킹을 담는 rank 배열을 선언하였다. rank 배열을 1로 다 초기화하고 진행하였다.
랭킹이 오르는 경우는 몸무게와 키 둘 다 다른 사용자보다 작을 때이므로 1. 입력받은 값이 작을 경우 2. 입력받은 값보다 작을 경우 로 나누어주어 이중 for문으로 진행했다.
바깥의 0~ n-1까지 for문을 돌리면서 입력을 받고, 내부의 for문에서 0 ~ i-1까지 비교를 하였으므로 2가지의 경우를 상정하였다.

## 부족한 방식
다른 사람의 코드를 보니, 먼저 사용자의 덩치를 입력받고 for문을 n번씩 이중 for문으로 진행하는 경우가 많았다. 나는 값을 하나하나씩 받고, 배열의 크기만큼 for문을 돌리고 싶었으므로 내부의 for문을 i-1로 돌렸다. 생각해보니 brute force에 맞지 않는 것 같은데.. 한번 알아봐야겠다.


<br>

